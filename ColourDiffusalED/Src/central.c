//$file${.::central.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: ColourDiffusal.qm
// File:  ${.::central.c}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::central.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "central.h"
#include "veml6040.h"
#include "sdd1306_font.h"
#include "bsp_gpio.h"
#include "app.h"

Q_DEFINE_THIS_FILE

/* instantiate the Central active object ------------------------------------*/
static Central l_central;
QActive * const AO_Central = &l_central.super;

static uint8_t calculateHue(uint16_t R, uint16_t G, uint16_t B); //internal linkage

/* ask QM to define the Central class ---------------------------------------*/
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AOs::Central_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Central_ctor} .......................................................
void Central_ctor(void) {
    Central *me = (Central *)AO_Central;
    QActive_ctor(&me->super, Q_STATE_CAST(&Central_initial));
    TickerKeeper_ctor(&me->tk);
}
//$enddef${AOs::Central_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Central} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Central} ............................................................

//${AOs::Central::SM} ........................................................
QState Central_initial(Central * const me, void const * const par) {
    //${AOs::Central::SM::initial}
    //USER CODE
    TickerKeeper_init(&me->tk);
    me->ledon = false;
    me->hue = 0;
    me->rgbCount.RCount = 0;
    me->rgbCount.GCount = 0;
    me->rgbCount.BCount = 0;
#ifdef DEBUG_CFG
	printf("Tick: %i, Central_initial\n",OSTimeGet());
#endif
	if(me->ledon){
		//Turn on LED
		bsp_gpio_PA7_set();
	}
	else{
		//Turn off LED
		bsp_gpio_PA7_reset();
	}
    return Q_TRAN(&Central_started);
}

//${AOs::Central::SM::started} ...............................................
QState Central_started(Central * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Central::SM::started}
        case Q_ENTRY_SIG: {
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_started: Q_ENTRY_SIG\n",OSTimeGet());
#endif
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started}
        case Q_EXIT_SIG: {
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_started: Q_EXIT_SIG\n",OSTimeGet());
#endif
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::initial}
        case Q_INIT_SIG: {
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_started: Q_INIT_SIG\n",OSTimeGet());
#endif
			//Draw area for HUE
			sdd1306_draw(HUEH_POS_Y,CAL_END_PAGE(HUEH_POS_Y),HUEH_POS_X,CAL_END_COLUMN(HUEH_POS_X),font16x16[13],LED_CHAR_16_SIZE);
			sdd1306_draw(HUEU_POS_Y,CAL_END_PAGE(HUEU_POS_Y),HUEU_POS_X,CAL_END_COLUMN(HUEU_POS_X),font16x16[16],LED_CHAR_16_SIZE);
			sdd1306_draw(HUEE_POS_Y,CAL_END_PAGE(HUEE_POS_Y),HUEE_POS_X,CAL_END_COLUMN(HUEE_POS_X),font16x16[12],LED_CHAR_16_SIZE);
			sdd1306_draw(HUE_COLON_POS_Y,CAL_END_PAGE(HUE_COLON_POS_Y),HUE_COLON_POS_X,CAL_END_COLUMN(HUE_COLON_POS_X),font16x16[10],LED_CHAR_16_SIZE);

            status_ = Q_TRAN(&Central_percentdata);
            break;
        }
        //${AOs::Central::SM::started::LEDTOGGLE}
        case LEDTOGGLE_SIG: {
            //${AOs::Central::SM::started::LEDTOGGLE::[Ledison]}
            if (me->ledon) {
                //USER CODE
#ifdef DEBUG_CFG
				printf("Tick: %i, Central_started: LEDTOGGLE_SIG LED off\n",OSTimeGet());
#endif
				//Turn off LED
				bsp_gpio_PB10_reset();
				me->ledon = false;
                status_ = Q_HANDLED();
            }
            //${AOs::Central::SM::started::LEDTOGGLE::[LedisOff]}
            else {
                //USER CODE
#ifdef DEBUG_CFG
				printf("Tick: %i, Central_started: LEDTOGGLE_SIG LED on\n",OSTimeGet());
#endif
				//Turn on LED
				bsp_gpio_PB10_set();
				me->ledon = true;
                status_ = Q_HANDLED();
            }
            break;
        }
        //${AOs::Central::SM::started::SENSOROBTAIN}
        case SENSOROBTAIN_SIG: {
            //Obtain sensor reading and calculate hue value
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_started: SENSOROBTAIN_SIG\n",OSTimeGet());
#endif
			//Obtain sensor reading and calculate hue value
			veml6040_get_data_raw(&(me->rgbCount));
			me->hue = calculateHue(me->rgbCount.RCount,me->rgbCount.GCount,me->rgbCount.BCount);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::PAUSE}
        case PAUSE_SIG: {
            //Dispatch to ticker keeper
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_started: PAUSE_SIG\n",OSTimeGet());
#endif
            TickerKeeper_dispatch(&me->tk, e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::Central::SM::started::percentdata} ..................................
QState Central_percentdata(Central * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Central::SM::started::percentdata}
        case Q_ENTRY_SIG: {
            //Write RBG and colon to the right location
            //Post to self with UPDATESCREEN Event
            //USER CODE
#ifdef DEBUG_CFG
		printf("Tick: %i, Central_percentdata: Q_ENTRY_SIG\n",OSTimeGet());
#endif
			//Write RBG and colon to the right location
			sdd1306_draw(R_POS_Y_MODE_0,CAL_END_PAGE(R_POS_Y_MODE_0),R_POS_X_MODE_0,CAL_END_COLUMN(R_POS_X_MODE_0),font16x16[15],LED_CHAR_16_SIZE);
			sdd1306_draw(R_COLON_POS_Y_MODE_0,CAL_END_PAGE(R_COLON_POS_Y_MODE_0),R_COLON_POS_X_MODE_0,CAL_END_COLUMN(R_COLON_POS_X_MODE_0),font16x16[10],LED_CHAR_16_SIZE);
			sdd1306_draw(G_POS_Y_MODE_0,CAL_END_PAGE(G_POS_Y_MODE_0),G_POS_X_MODE_0,CAL_END_COLUMN(G_POS_X_MODE_0),font16x16[14],LED_CHAR_16_SIZE);
			sdd1306_draw(G_COLON_POS_Y_MODE_0,CAL_END_PAGE(G_COLON_POS_Y_MODE_0),G_COLON_POS_X_MODE_0,CAL_END_COLUMN(G_COLON_POS_X_MODE_0),font16x16[10],LED_CHAR_16_SIZE);
			sdd1306_draw(B_POS_Y_MODE_0,CAL_END_PAGE(B_POS_Y_MODE_0),B_POS_X_MODE_0,CAL_END_COLUMN(B_POS_X_MODE_0),font16x16[11],LED_CHAR_16_SIZE);
			sdd1306_draw(B_COLON_POS_Y_MODE_0,CAL_END_PAGE(B_COLON_POS_Y_MODE_0),B_COLON_POS_X_MODE_0,CAL_END_COLUMN(B_COLON_POS_X_MODE_0),font16x16[10],LED_CHAR_16_SIZE);
			const QEvt *pe = Q_NEW(QEvt, UPDATESCREEN_SIG);
			QACTIVE_POST(&me->super,pe,((void*)0));
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::percentdata}
        case Q_EXIT_SIG: {
            //Clear screen
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_percentdata: Q_EXIT_SIG\n",OSTimeGet());
#endif
			sdd1306_clear_area(MODE_CLEAR_AREA_Y_START,MODE_CLEAR_AREA_Y_END,MODE_CLEAR_AREA_X_START,MODE_CLEAR_AREA_X_END);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::percentdata::UPDATESCREEN}
        case UPDATESCREEN_SIG: {
            //Calculate RGB as percent and display
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_percentdata: UPDATESCREEN_SIG\n",OSTimeGet());
#endif
			//Calculate RGB as percent and display together with HUE
			uint16_t R = me->rgbCount.RCount;
			uint16_t G = me->rgbCount.GCount;
			uint16_t B = me->rgbCount.BCount;
			uint32_t total = R+B+G;
			uint8_t percR = (R*100+(total>>1))/total;
			uint8_t percG = (G*100+(total>>1))/total;
			uint8_t percB = (B*100+(total>>1))/total;

			uint8_t digitR0 =  percR % 10;    // Ones place
			uint8_t digitR1 = (percR / 10) % 10; // Tens place
			uint8_t digitR2 = (percR / 100) % 10; // Hundreds place

			uint8_t digitG0 =  percG % 10;    // Ones place
			uint8_t digitG1 = (percG / 10) % 10; // Tens place
			uint8_t digitG2 = (percG / 100) % 10; // Hundreds place

			uint8_t digitB0 =  percB % 10;    // Ones place
			uint8_t digitB1 = (percB / 10) % 10; // Tens place
			uint8_t digitB2 = (percB / 100) % 10; // Hundreds place

			sdd1306_draw(R1_POS_Y_MODE_0,CAL_END_PAGE(R1_POS_Y_MODE_0),R1_POS_X_MODE_0,CAL_END_COLUMN(R1_POS_X_MODE_0),font16x16[digitR0],LED_CHAR_16_SIZE);
			sdd1306_draw(R2_POS_Y_MODE_0,CAL_END_PAGE(R2_POS_Y_MODE_0),R2_POS_X_MODE_0,CAL_END_COLUMN(R2_POS_X_MODE_0),font16x16[digitR1],LED_CHAR_16_SIZE);
			sdd1306_draw(R3_POS_Y_MODE_0,CAL_END_PAGE(R3_POS_Y_MODE_0),R3_POS_X_MODE_0,CAL_END_COLUMN(R3_POS_X_MODE_0),font16x16[digitR2],LED_CHAR_16_SIZE);

			sdd1306_draw(G1_POS_Y_MODE_0,CAL_END_PAGE(G1_POS_Y_MODE_0),G1_POS_X_MODE_0,CAL_END_COLUMN(G1_POS_X_MODE_0),font16x16[digitG0],LED_CHAR_16_SIZE);
			sdd1306_draw(G2_POS_Y_MODE_0,CAL_END_PAGE(G2_POS_Y_MODE_0),G2_POS_X_MODE_0,CAL_END_COLUMN(G2_POS_X_MODE_0),font16x16[digitG1],LED_CHAR_16_SIZE);
			sdd1306_draw(G3_POS_Y_MODE_0,CAL_END_PAGE(G3_POS_Y_MODE_0),G3_POS_X_MODE_0,CAL_END_COLUMN(G3_POS_X_MODE_0),font16x16[digitG2],LED_CHAR_16_SIZE);

			sdd1306_draw(B1_POS_Y_MODE_0,CAL_END_PAGE(B1_POS_Y_MODE_0),B1_POS_X_MODE_0,CAL_END_COLUMN(B1_POS_X_MODE_0),font16x16[digitB0],LED_CHAR_16_SIZE);
			sdd1306_draw(B2_POS_Y_MODE_0,CAL_END_PAGE(B2_POS_Y_MODE_0),B2_POS_X_MODE_0,CAL_END_COLUMN(B2_POS_X_MODE_0),font16x16[digitB1],LED_CHAR_16_SIZE);
			sdd1306_draw(B3_POS_Y_MODE_0,CAL_END_PAGE(B3_POS_Y_MODE_0),B3_POS_X_MODE_0,CAL_END_COLUMN(B3_POS_X_MODE_0),font16x16[digitB2],LED_CHAR_16_SIZE);

			sdd1306_draw(HUE1_POS_Y,CAL_END_PAGE(HUE1_POS_Y),HUE1_POS_X,CAL_END_COLUMN(HUE1_POS_X),font16x16[(me->hue % 10)],LED_CHAR_16_SIZE);
			sdd1306_draw(HUE2_POS_Y,CAL_END_PAGE(HUE2_POS_Y),HUE2_POS_X,CAL_END_COLUMN(HUE2_POS_X),font16x16[((me->hue / 10) % 10)],LED_CHAR_16_SIZE);
			sdd1306_draw(HUE3_POS_Y,CAL_END_PAGE(HUE3_POS_Y),HUE3_POS_X,CAL_END_COLUMN(HUE3_POS_X),font16x16[((me->hue / 100) % 10)],LED_CHAR_16_SIZE);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::percentdata::SWITCHMODE}
        case SWITCHMODE_SIG: {
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_percentdata: SWITCHMODE_SIG\n",OSTimeGet());
#endif
            status_ = Q_TRAN(&Central_rawdata);
            break;
        }
        default: {
            status_ = Q_SUPER(&Central_started);
            break;
        }
    }
    return status_;
}

//${AOs::Central::SM::started::rawdata} ......................................
QState Central_rawdata(Central * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Central::SM::started::rawdata}
        case Q_ENTRY_SIG: {
            //Write RBG and colon to the right location
            //Post to self with UPDATESCREEN Event
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_rawdata: Q_ENTRY_SIG\n",OSTimeGet());
#endif
			//Write RBG and colon to the right location
			sdd1306_draw(R_POS_Y_MODE_1,CAL_END_PAGE(R_POS_Y_MODE_1),R_POS_X_MODE_1,CAL_END_COLUMN(R_POS_X_MODE_1),font16x16[15],LED_CHAR_16_SIZE);
			sdd1306_draw(R_COLON_POS_Y_MODE_1,CAL_END_PAGE(R_COLON_POS_Y_MODE_1),R_COLON_POS_X_MODE_1,CAL_END_COLUMN(R_COLON_POS_X_MODE_1),font16x16[10],LED_CHAR_16_SIZE);
			sdd1306_draw(G_POS_Y_MODE_1,CAL_END_PAGE(G_POS_Y_MODE_1),G_POS_X_MODE_1,CAL_END_COLUMN(G_POS_X_MODE_1),font16x16[14],LED_CHAR_16_SIZE);
			sdd1306_draw(G_COLON_POS_Y_MODE_1,CAL_END_PAGE(G_COLON_POS_Y_MODE_1),G_COLON_POS_X_MODE_1,CAL_END_COLUMN(G_COLON_POS_X_MODE_1),font16x16[10],LED_CHAR_16_SIZE);
			sdd1306_draw(B_POS_Y_MODE_1,CAL_END_PAGE(B_POS_Y_MODE_1),B_POS_X_MODE_1,CAL_END_COLUMN(B_POS_X_MODE_1),font16x16[11],LED_CHAR_16_SIZE);
			sdd1306_draw(B_COLON_POS_Y_MODE_1,CAL_END_PAGE(B_COLON_POS_Y_MODE_1),B_COLON_POS_X_MODE_1,CAL_END_COLUMN(B_COLON_POS_X_MODE_1),font16x16[10],LED_CHAR_16_SIZE);
            const QEvt *pe = Q_NEW(QEvt, UPDATESCREEN_SIG);
            QACTIVE_POST(&me->super,pe,((void*)0));
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::rawdata}
        case Q_EXIT_SIG: {
            //Clear screen
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_rawdata: Q_EXIT_SIG\n",OSTimeGet());
#endif
            sdd1306_clear_area(MODE_CLEAR_AREA_Y_START,MODE_CLEAR_AREA_Y_END,MODE_CLEAR_AREA_X_START,MODE_CLEAR_AREA_X_END);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::rawdata::UPDATESCREEN}
        case UPDATESCREEN_SIG: {
            //Display RGB as raw datas
            //USER CODE
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_rawdata: UPDATESCREEN_SIG\n",OSTimeGet());
#endif
			//Display RGB as raw datas
			uint16_t R = me->rgbCount.RCount;
			uint16_t G = me->rgbCount.GCount;
			uint16_t B = me->rgbCount.BCount;
			uint8_t digitR0 =  R % 10;    // Ones placeX
			uint8_t digitR1 = (R / 10) % 10; // Tens place
			uint8_t digitR2 = (R / 100) % 10; // Hundreds place
			uint8_t digitR3 = (R / 1000) % 10; // Thousands place
			uint8_t digitR4 =  R / 10000; // Ten-Thousand place

			uint8_t digitG0 =  G % 10;    // Ones place
			uint8_t digitG1 = (G / 10) % 10; // Tens place
			uint8_t digitG2 = (G / 100) % 10; // Hundreds place
			uint8_t digitG3 = (G / 1000) % 10; // Thousands place
			uint8_t digitG4 =  G / 10000; // Ten-Thousand place

			uint8_t digitB0 =  B % 10;    // Ones place
			uint8_t digitB1 = (B / 10) % 10; // Tens place
			uint8_t digitB2 = (B / 100) % 10; // Hundreds place
			uint8_t digitB3 = (B / 1000) % 10; // Thousands place
			uint8_t digitB4 =  B / 10000; // Ten-Thousand place

			sdd1306_draw(R1_POS_Y_MODE_1,CAL_END_PAGE(R1_POS_Y_MODE_1),R1_POS_X_MODE_1,CAL_END_COLUMN(R1_POS_X_MODE_1),font16x16[digitR0],LED_CHAR_16_SIZE);
			sdd1306_draw(R2_POS_Y_MODE_1,CAL_END_PAGE(R2_POS_Y_MODE_1),R2_POS_X_MODE_1,CAL_END_COLUMN(R2_POS_X_MODE_1),font16x16[digitR1],LED_CHAR_16_SIZE);
			sdd1306_draw(R3_POS_Y_MODE_1,CAL_END_PAGE(R3_POS_Y_MODE_1),R3_POS_X_MODE_1,CAL_END_COLUMN(R3_POS_X_MODE_1),font16x16[digitR2],LED_CHAR_16_SIZE);
			sdd1306_draw(R4_POS_Y_MODE_1,CAL_END_PAGE(R4_POS_Y_MODE_1),R4_POS_X_MODE_1,CAL_END_COLUMN(R4_POS_X_MODE_1),font16x16[digitR3],LED_CHAR_16_SIZE);
			sdd1306_draw(R5_POS_Y_MODE_1,CAL_END_PAGE(R5_POS_Y_MODE_1),R5_POS_X_MODE_1,CAL_END_COLUMN(R5_POS_X_MODE_1),font16x16[digitR4],LED_CHAR_16_SIZE);

			sdd1306_draw(G1_POS_Y_MODE_1,CAL_END_PAGE(G1_POS_Y_MODE_1),G1_POS_X_MODE_1,CAL_END_COLUMN(G1_POS_X_MODE_1),font16x16[digitG0],LED_CHAR_16_SIZE);
			sdd1306_draw(G2_POS_Y_MODE_1,CAL_END_PAGE(G2_POS_Y_MODE_1),G2_POS_X_MODE_1,CAL_END_COLUMN(G2_POS_X_MODE_1),font16x16[digitG1],LED_CHAR_16_SIZE);
			sdd1306_draw(G3_POS_Y_MODE_1,CAL_END_PAGE(G3_POS_Y_MODE_1),G3_POS_X_MODE_1,CAL_END_COLUMN(G3_POS_X_MODE_1),font16x16[digitG2],LED_CHAR_16_SIZE);
			sdd1306_draw(G4_POS_Y_MODE_1,CAL_END_PAGE(G4_POS_Y_MODE_1),G4_POS_X_MODE_1,CAL_END_COLUMN(G4_POS_X_MODE_1),font16x16[digitG3],LED_CHAR_16_SIZE);
			sdd1306_draw(G5_POS_Y_MODE_1,CAL_END_PAGE(G5_POS_Y_MODE_1),G5_POS_X_MODE_1,CAL_END_COLUMN(G5_POS_X_MODE_1),font16x16[digitG4],LED_CHAR_16_SIZE);

			sdd1306_draw(B1_POS_Y_MODE_1,CAL_END_PAGE(B1_POS_Y_MODE_1),B1_POS_X_MODE_1,CAL_END_COLUMN(B1_POS_X_MODE_1),font16x16[digitB0],LED_CHAR_16_SIZE);
			sdd1306_draw(B2_POS_Y_MODE_1,CAL_END_PAGE(B2_POS_Y_MODE_1),B2_POS_X_MODE_1,CAL_END_COLUMN(B2_POS_X_MODE_1),font16x16[digitB1],LED_CHAR_16_SIZE);
			sdd1306_draw(B3_POS_Y_MODE_1,CAL_END_PAGE(B3_POS_Y_MODE_1),B3_POS_X_MODE_1,CAL_END_COLUMN(B3_POS_X_MODE_1),font16x16[digitB2],LED_CHAR_16_SIZE);
			sdd1306_draw(B4_POS_Y_MODE_1,CAL_END_PAGE(B4_POS_Y_MODE_1),B4_POS_X_MODE_1,CAL_END_COLUMN(B4_POS_X_MODE_1),font16x16[digitB3],LED_CHAR_16_SIZE);
			sdd1306_draw(B5_POS_Y_MODE_1,CAL_END_PAGE(B5_POS_Y_MODE_1),B5_POS_X_MODE_1,CAL_END_COLUMN(B5_POS_X_MODE_1),font16x16[digitB4],LED_CHAR_16_SIZE);

			sdd1306_draw(HUE1_POS_Y,CAL_END_PAGE(HUE1_POS_Y),HUE1_POS_X,CAL_END_COLUMN(HUE1_POS_X),font16x16[(me->hue % 10)],LED_CHAR_16_SIZE);
			sdd1306_draw(HUE2_POS_Y,CAL_END_PAGE(HUE2_POS_Y),HUE2_POS_X,CAL_END_COLUMN(HUE2_POS_X),font16x16[((me->hue / 10) % 10)],LED_CHAR_16_SIZE);
			sdd1306_draw(HUE3_POS_Y,CAL_END_PAGE(HUE3_POS_Y),HUE3_POS_X,CAL_END_COLUMN(HUE3_POS_X),font16x16[((me->hue / 100) % 10)],LED_CHAR_16_SIZE);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Central::SM::started::rawdata::SWITCHMODE}
        case SWITCHMODE_SIG: {
#ifdef DEBUG_CFG
			printf("Tick: %i, Central_rawdata: SWITCHMODE_SIG\n",OSTimeGet());
#endif
            status_ = Q_TRAN(&Central_percentdata);
            break;
        }
        default: {
            status_ = Q_SUPER(&Central_started);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::Central} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

static uint8_t calculateHue(uint16_t R, uint16_t G, uint16_t B){
	//fixed point arithmetic
	//https://changingminds.org/explanations/perception/visual/hsl.html
		int32_t RNorm = (R<<12)/65535; //0.12
    int32_t GNorm = (G<<12)/65535; //0.12
    int32_t BNorm = (B<<12)/65535; //0.12
		
		uint8_t MaxRGB = 0;
		uint32_t Cmin = RNorm; //0.12
    uint32_t Cmax = RNorm; //0.12
		if(GNorm<Cmin){
			Cmin=GNorm;
		}else if(GNorm>Cmax){
			Cmax=GNorm;
			MaxRGB=1;
		}
		
		if(BNorm<Cmin){
			Cmin=BNorm;
		}else if(BNorm>Cmax){
			Cmax=BNorm;
			MaxRGB=2;
		}
		int32_t delta = Cmax-Cmin; //0.12
		int32_t hue = 0;
		if(MaxRGB==0){ //red is max
				hue = 60*(((((GNorm<<8)-(BNorm<<8))%(6<<20))+(delta>>1))/delta); //intermediate cast to prevent conversion rule messing up the result
		}else if(MaxRGB==1){ //green is max
				hue = 60*((2<<8)+(((BNorm<<8)-(RNorm<<8))+(delta>>1))/delta);
		}else{ //blue is max
				hue = 60*((4<<8)+(((RNorm<<8)-(GNorm<<8))+(delta>>1))/delta);
		}
		//hue is 0.8
		if(hue<0){
				hue = hue +(360<<8);
		}
		hue = hue >> 8;
		
		return hue;
}
